<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Mouse Track</title>

	<script src="/Scripts/json2.js"></script>	<!--JSON 库要放在 SignalR 库的前面 -->
    <script src="/Scripts/jquery-1.9.1.js"></script>
    <script src="/Scripts/jquery.signalR-1.1.3.min.js"></script>
    
    <script src="tracking.js"></script>
    <style>
        .client {
            position: absolute;
            background-color: white;
            -moz-box-shadow: 10px 10px 5px #888;
            -webkit-box-shadow: 10px 10px 5px #888;
            box-shadow: 3px 3px 3px #888;
            border: 1px solid #a0a0a0;
            padding: 3px;
        }
    </style>
</head>
<body>
    <h1>Lorem ipsum</h1>
    <p>Indubitably, persistent 
connections provide all that we 
may need to create real-time 
multiuser applications through a 
really simple and intuitive API. 
Nevertheless, the creators of 
SignalR have taken it one step 
further, offering  a much higher 
level of abstractionabove Web 
protocols, transports and 
persistent connections. Hubs use 
an imperative development model based on the flexibility of dynamic languages such 
as Javascript and C# which creates an illusion of continuitybetween these two levels 
which are physically detached. 
Hubs are thus  the higher-level API  that we can use to access the persistent 
connection created by SignalR. We can create the same applications using persistent 
connections, but if we choose hubs it will be simpler. 
Although there are two different approaches to working with hubs in SignalR, the 
most common model used in Web environments allows us to make direct calls between 
client-side and server-side methods transparently. That is,  from the client we will 
directly invoke methods available at the server, and vice versa:</p>
    <p>Indubitably, persistent 
connections provide all that we 
may need to create real-time 
multiuser applications through a 
really simple and intuitive API. 
Nevertheless, the creators of 
SignalR have taken it one step 
further, offering  a much higher 
level of abstractionabove Web 
protocols, transports and 
persistent connections. Hubs use 
an imperative development model based on the flexibility of dynamic languages such 
as Javascript and C# which creates an illusion of continuitybetween these two levels 
which are physically detached. 
Hubs are thus  the higher-level API  that we can use to access the persistent 
connection created by SignalR. We can create the same applications using persistent 
connections, but if we choose hubs it will be simpler. 
Although there are two different approaches to working with hubs in SignalR, the 
most common model used in Web environments allows us to make direct calls between 
client-side and server-side methods transparently. That is,  from the client we will 
directly invoke methods available at the server, and vice versa:</p>
    <p>Indubitably, persistent 
connections provide all that we 
may need to create real-time 
multiuser applications through a 
really simple and intuitive API. 
Nevertheless, the creators of 
SignalR have taken it one step 
further, offering  a much higher 
level of abstractionabove Web 
protocols, transports and 
persistent connections. Hubs use 
an imperative development model based on the flexibility of dynamic languages such 
as Javascript and C# which creates an illusion of continuitybetween these two levels 
which are physically detached. 
Hubs are thus  the higher-level API  that we can use to access the persistent 
connection created by SignalR. We can create the same applications using persistent 
connections, but if we choose hubs it will be simpler. 
Although there are two different approaches to working with hubs in SignalR, the 
most common model used in Web environments allows us to make direct calls between 
client-side and server-side methods transparently. That is,  from the client we will 
directly invoke methods available at the server, and vice versa:</p>
    <p>Indubitably, persistent 
connections provide all that we 
may need to create real-time 
multiuser applications through a 
really simple and intuitive API. 
Nevertheless, the creators of 
SignalR have taken it one step 
further, offering  a much higher 
level of abstractionabove Web 
protocols, transports and 
persistent connections. Hubs use 
an imperative development model based on the flexibility of dynamic languages such 
as Javascript and C# which creates an illusion of continuitybetween these two levels 
which are physically detached. 
Hubs are thus  the higher-level API  that we can use to access the persistent 
connection created by SignalR. We can create the same applications using persistent 
connections, but if we choose hubs it will be simpler. 
Although there are two different approaches to working with hubs in SignalR, the 
most common model used in Web environments allows us to make direct calls between 
client-side and server-side methods transparently. That is,  from the client we will 
directly invoke methods available at the server, and vice versa:</p>
</body>
</html>
